#include "StdAfx.h"
#include "HexenDecoder.h"
#include <vector>

CHexenDecoder::CHexenDecoder(void)
{
}

CHexenDecoder::~CHexenDecoder(void)
{
}

unsigned short CHexenDecoder::CharArrayToShort(unsigned char* currentSpot)
{
	return ((currentSpot[0] << 8) | currentSpot[1]);
}

unsigned long CHexenDecoder::CharArrayToLong(unsigned char* currentSpot)
{
	return ((((((currentSpot[0] << 8) | currentSpot[1]) << 8) | currentSpot[2]) << 8) | currentSpot[3]);
}
unsigned char CHexenDecoder::d_code[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
    0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
    0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
    0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
    0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
    0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
    0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
    0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
    0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
    0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};

	unsigned char CHexenDecoder::d_len[256] = {
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08};

    void CHexenDecoder::init()
	{
        //// Initialize each list w/ zeroes before filling.
		freq.resize(0x2FB + 1);
		for (int x = 0; x < 0x2FB + 1;  x++)
			freq[x] = 0x00;

		prnt.resize(0x2FB + 0x17E);
		for (int x = 0; x < 0x2FB + 0x17E;  x++)
			prnt[x] = 0x00;

		son.resize(0x2FB);
		for (int x = 0; x < 0x2FB;  x++)
			son[x] = 0x00;

        for (int i = 0; i < 0x17E; i++)
		{
            freq[i] = 1;
            prnt[i+0x2FB] = i;
            son[i] = 0x2FB + i;
		}
        for (int i = 0x17E; i < 0x2FB; i++)
		{
            int j = (i - 0x17E) << 1;
            int k = 0x17E + j;
            freq[i] = freq[j] + freq[j+1];
            prnt[j] = i;
            prnt[j+1] = i;
            son[i] = j;
		}
        prnt[0x2FA] = 0;
        freq[0x2FB] = -1;
        //// Data stream things for decoding.
        data = NULL;
        bitc = 0;
	}

    //// Little bit of magic.  self.src returns current byte, self.src = data sets datastream
    //@property
    unsigned char CHexenDecoder::src()
	{
        return data[0];
	}

    void CHexenDecoder::src(unsigned char* data)
	{
        this->data = data;
        this->bitc = 0;
	}

    int CHexenDecoder::next(int length)
	{
        // A...noniterable iterable?
        int i = (1 << length) - 1;
        int j = src();
        if ((bitc + length) >= 8)
		{
			data++;
            j |= src() << 8;
		}
        j >>= bitc;
        bitc += length;
        bitc &= 7;
        return j & i;
	}

    void CHexenDecoder::_h_refill()
	{
        int j = 0;
        for (int i = 0; i < 0x2FB; i++)  // collect leaves in first half
		{
            int v = son[i];
            if (v < 0x2FB)
				continue;
            int k = freq[i] + 1;
            if (k < 0)
				k += 1;
            freq[j] = k >> 1;
            son[j] = v;
            j += 1;
		}
        int i = 0;
        for (int j = 0x17E; j < 0x2FB; j++) // connect sons
		{
            int k = (freq[i] + freq[i + 1]) & 0xFFFF;
            freq[j] = k;
            int v = j - 1;
            while (k < freq[v])
				v -= 1;
            v += 1;
			//freq[v+1:j+1] = freq[v:j];
			std::vector<int> tempBuffer;
			for (int x = v; x < j; x++)
				tempBuffer.push_back(freq[x]);
			for (int x = v+1; x < j+1; x++)
			{
				freq[x] = tempBuffer[0];
				tempBuffer.erase(tempBuffer.begin());
			}
            freq[v] = k;
			//son[v+1:j+1] = son[v:j];
			tempBuffer.clear();
			for (int x = v; x < j; x++)
				tempBuffer.push_back(son[x]);
			for (int x = v+1; x < j+1; x++)
			{
				son[x] = tempBuffer[0];
				tempBuffer.erase(tempBuffer.begin());
			}
            son[v] = i;
            i += 2;
		}
        for (int i = 0; i < 0x2FB; i++)  // connect parents
		{
            int v = son[i];
            prnt[v] = i;
            if (v < 0x2FB)
                prnt[v+1] = i;
		}
	}

    void CHexenDecoder::_h_update(int idx)
	{
        if (freq[0x2FA] == 0x8000)  // When ceiling met, reconstitute at max frequency.
            _h_refill();
        int i = prnt[0x2FB + idx];
        while (true)
		{
            freq[i] += 1;
            int j = i + 1;
            int q = freq[i];
            if ((0 <= freq[j]) && (freq[j] < q))    // Not a mistake.
			{
                while ((0 <= freq[j + 1]) && (freq[j + 1] < q))
					j += 1;
                int v = son[i];
                freq[i] = freq[j];
                freq[j] = q;
                prnt[v] = j;
                if (v < 0x2FB)
					prnt[v + 1] = j;
                int k = son[j];
                son[j] = v;
                prnt[k] = i;
                if (k < 0x2FB)
					prnt[k + 1] = i;
                son[i] = k;
			}
            else
			{
                j = i;
			}
            i = prnt[j];
            if (i == 0)
				break;
		}
	}

    int CHexenDecoder::_h_chr()
	{
        int i = son[0x2FA];
        while (i < 0x2FB)
		{
            i += next(1);
            i = son[i & 0xFFFF];
		}
        i -= 0x2FB;
        _h_update(i);
        return i;
	}

    int CHexenDecoder::_h_pos()
	{
        int j = next(8);
        int q = d_len[j] - 2;
        int k = (d_code[j] << 6) & 0xFFFF;
        int v = next(q);
        v += j << q;
        k += v & 0x3F;
        return k;
	}

    // Defined in a weird way so you can just type lzhuff.decode(yada yada)
	int CHexenDecoder::decode(unsigned char* input, unsigned char* output, int length)
	{
		int outputPosition = 0;
        int p = 0;
        // If length not given, read from start of file.
        if (length < 0)
		{
			length = CharArrayToLong(&input[0]);
            p = 4;
		}
        // Set up ring.  Only first 0xF80 need to be set to ' '.
		unsigned char tbl[0x1000];
		for (int x = 0; x < 0x1000; x++)
			tbl[x] = 0x20;
        int tbl_p = 0xF80;
        // Init data stream & huffman tables.

		init();
        this->data = &input[p];

        while (outputPosition < length)
		{
            int i = _h_chr();
            if (i < 0x100)
			{
				output[outputPosition++] = i;
                tbl[tbl_p] = i;
                tbl_p += 1;
                tbl_p &= 0xFFF;
			}
            else
			{
                int j = _h_pos();
                p = (tbl_p - j - 1) & 0xFFF;
                i -= 0xFD;	// len + 3
                for (int x = 0; x < i; x++)
				{
                    output[outputPosition++] = tbl[p];
                    tbl[tbl_p] = tbl[p];
                    p += 1;
                    p &= 0xFFF;
                    tbl_p += 1;
                    tbl_p &= 0xFFF;
				}
			}
		}
		return outputPosition;
	}